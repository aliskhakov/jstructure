---
title: "Повторная обработка сообщений в RabbitMQ с различным временным интервалом ожидания между повторами"
date: 2017-12-28T09:47:28+03:00
draft: false
tags: ["RabbitMQ", "DLX"]
description: 'На практике бывают случаи, когда при сбоях между повторами выполнения задач, необходимо подождать какое-то время. Например, в процессе выполнения задачи внешняя система была недоступна. Так как количество повторов как правило лимитировано, нет смысла тут же пробовать выполнить задачу еще раз. Внешняя система может стать доступной напрмер через минуту. Я слегка касался возможности задавания временного интервала между попытками обработки сообщений в статье &laquo;[Повторное выполнение задач в RabbitMQ](/post/re-execution-of-tasks-in-rabbitmq/)&raquo;. Однако, бывают случаи, когда необходимо после каждой неудачной попытки изменять временной интервал перед следующим повтором. В этой статье усложним функционал повторного выполнения задач, добавив возможность задания различного временного интервала между попытками обработки сообщений.'
---

Попробуем модифицировать [решение 4]({{< relref "post/re-execution-of-tasks-in-rabbitmq.md" >}}), обеспечивающееся следующей схемой. На входе имеем точку обмена *WorkExchange*. На нее подписана очередь *WorkQueue*, которая отправляет сбойные сообщения в точку обмена *RetryExchange* (*DLX*). Оттуда сообщения перенаправляются в очередь *RetryQueue*, объявленную с параметром `x-message-ttl`. При дотижении заданного *TTL* сообщение заново публикуется в *WorkExchange* и опять попадает в очередь *WorkQueue*. Этот цикл можно повторять до достижения заданного в слушателе лимита.

Первым делом в голову приходит мысль добавления нескольких очередей для *RetryExchange*, с различными параметрами `x-message-ttl`. Для этого нужно реализовать роутинг в точке обмена *RetryExchange*. Рассмотрим различные типы точек обмена, существующие в RabbitMQ. Так как *routing key* у всех сообщений одинаковый, типы *direct* и *topic* для точки доступа *RetryExchange* не подойдут, не смотря на то, что при возврате сообщения в очередь, можно поменять *routing key*, так как это будет происходить для всех сообщений. Очевидно, что тип *fanout* тоже не подходит, так как разветвление в данном случае не имеет смылса, нам же нужен роутинг. А вот на типе *headers* можно попробовать остановиться. Дело в том, что сообщения, попадающие в точку обмена *DLX*, имеют специальный заголовок `x-death`, содержащий в себе список словарей, которые содерджат информацию о количестве попаданий в различные точки обмена *DLX* при разных условиях. Пример заголовка `x-death` показан ниже.

```
x-death:        count: 4
             exchange: RetryExchange
                queue: RetryQueue
               reason: expired
         routing-keys: WorkQueue
                 time: 1510583141
                 
                count: 3
             exchange: WorkExchange
                queue: WorkQueue
               reason: rejected
         routing-keys: WorkQueue
                 time: 1510583141
```

Видно, вся информация имеетя, но в RabbitMQ отсутствует возможность связывания очереди с точкой обмена по вложенным заголовкам, например, по правилу `x-death[1].count = 3`. Таким образом, вынуждены отказаться от идеи добавления нескольких очередей для *RetryExchange*, потому что в *RabbitMQ* не возможно реализовать соответствующий роутинг.

Идем дальше. Можно попробовать создать цепочку *dead-letter* очередей с различными параметрами `x-message-ttl`, как показано на схеме ниже. После каждой *dead-letter* очереди, сообщение, минуя соответсвующую точку обмена *DLX* попадает в новую очередь задач. Слушатель подписан на каждую из них.

![Схема с подписчиком dead-letter очереди](/images/re-execution-of-tasks-with-different-repetition-waiting-times-in-rabbitmq/multiple-ttl.png)

Эта схема будет работать, но выглядит довольно громоздкой. Очевидно, что размер схемы зависит от количества попыток. Так, если лимит количества попыток равен 10, нужно созадть 18 точек обмена и 19 очередей, а слушателю нужно быть подписанным на 10 очередей. Также к недостаткам этого решения можно отнести сложность переконфигурировани *TTL* для одной или нескольких очередей. Так как `x-message-ttl` задается при декларировании очереди, необходимо удалить и создать очереди заново. При этом нужно обеспечить сохранность сообщений, находящихся в них в данный момент времени.

Следующая мысль, которая приходит в голову &mdash; создание подписчика для *dead-letter* очереди, который периодически забирает сообщения и выпоняет *reject* либо с `requeue=true`, либо с `requeue=false`. При передаче `requeue=true` сообщение останется в *dead-letter* очереди до следующего получения его подписчиком *dead-letter* очереди. Если же передать `requeue=false`, сообщение уйдет в точу обмена *WorkExchange*, откуда снова попадет в очередь *WorkQueue* для следующей попытки. Ниже представлена схема реализации.

![Схема с подписчиком dead-letter очереди](/images/re-execution-of-tasks-with-different-repetition-waiting-times-in-rabbitmq/dlq-consumer.png)

В данном случае подписчик сам понимает, нужно ли отправлять сообщение на повторное выполнение, например, в зависимости от параметров `count` и `time` соответствующего подзаголовка `x-death` сообщения. В отличие от предыдущего способа, эта схема не является громоздкой и ее размер не зависит от лимита на количество повторов. Также нет необходимости пересоздавать очереди при переконфигурировании времени ожидания. Само время ожидания между повторами может формироваться по определнному закону, например: `2 * count`. Это может быть удобным в некоторых случаях.
