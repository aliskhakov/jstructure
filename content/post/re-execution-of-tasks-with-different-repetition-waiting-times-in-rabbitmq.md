---
title: "Повторная обработка сообщений в RabbitMQ с различным временным интервалом ожидания между повторами"
date: 2017-12-28T09:47:28+03:00
draft: false
tags: ["RabbitMQ", "DLX"]
description: 'Я уже писал про &laquo;[повторное выполнение задач в RabbitMQ](/post/re-execution-of-tasks-in-rabbitmq/)&raquo;. Однако, бывают случаи, когда необходимо после каждой неудачной попытки увеличивать временной интервал перед следующим повтором. В этой статье усложним функционал повторного выполнения задач, добавив возможность задания различного временного интервала между попытками обработки сообщений.'
---

Попробуем модифицировать [решение 4]({{< relref "post/re-execution-of-tasks-in-rabbitmq.md" >}}), которое устроено следующим образом. На входе имеем точку обмена *WorkExchange*. На нее подписана очередь *WorkQueue*, которая отправляет сбойные сообщения в *RetryExchange* (*DLX*). Оттуда сообщения перенаправляются в очередь *RetryQueue*, объявленную с параметром `x-message-ttl`. При дотижении заданного *TTL* сообщение заново публикуется в *WorkExchange* и опять попадает в очередь *WorkQueue*. Этот цикл можно повторять до достижения заданного в слушателе лимита.

Первым делом в голову приходит мысль добавления нескольких очередей для *RetryExchange*, с различными параметрами `x-message-ttl`. Для этого нужно реализовать роутинг в точке обмена *RetryExchange*. Рассмотрим различные типы точек обмена, существующие в RabbitMQ. Так как *routing key* у всех сообщений одинаковый, типы *direct* и *topic* для точки доступа *RetryExchange* не подойдут, не смотря на то, что при возврате сообщения в очередь, можно поменять *routing key*, так как это будет происходить для всех сообщений. Очевидно, что тип *fanout* тоже не подходит, так как разветвление в данном случае не имеет смылса, нам же нужен роутинг. А вот на типе *headers* можно попробовать остановиться. Дело в том, что сообщения, попадающие в *DLX*, имеют специальный заголовок `x-death`, содержащий в себе список словарей, которые содерджат информацию о количестве попаданий в различные *DLX* при разных условиях. Пример заголовка `x-death` показан ниже.

```
x-death:        count: 4
             exchange: RetryExchange
                queue: RetryQueue
               reason: expired
         routing-keys: WorkQueue
                 time: 1510583141
                 
                count: 3
             exchange: WorkExchange
                queue: WorkQueue
               reason: rejected
         routing-keys: WorkQueue
                 time: 1510583141
```

Видно, вся информация имеетя, но в RabbitMQ отсутствует возможность связывания очереди с точкой обмена по вложенным заголовкам, например, по правилу `x-death[1].count = 3`. Таким образом, вынуждены отказаться от идеи добавления нескольких очередей для *RetryExchange*, потому что в *RabbitMQ* не возможно реализовать соответствующий роутинг.

Идем дальше. Можно попробовать создать цепочку *dead-letter* очередей с различными параметрами `x-message-ttl`, как показано на схеме ниже. После каждой *dead-letter* очереди, сообщение, минуя соответсвующий *DLX* попадает в новую очередь задач. Слушатель подписан на каждую из них.

![Схема с подписчиком dead-letter очереди](/images/re-execution-of-tasks-with-different-repetition-waiting-times-in-rabbitmq/multiple-ttl.png)

Эта схема будет работать, но выглядит довольно громоздкой. Очевидно, что размер схемы зависит от количества попыток. Так, если лимит количества попыток равен 10, нужно созадть 18 точек обмена и 19 очередей, а слушателю нужно быть подписанным на 10 очередей. Также к недостаткам этого решения можно отнести сложность переконфигурировани `TTL` для одной или нескольких очередей. Так как `x-message-ttl` задается при декларировании очереди, необходимо удалить и создать очереди заново. При этом нужно обеспечить сохранность сообщений, находящихся в них в данный момент времени.

Следующая мысль, которая приходит в голову &mdash; создание подписчика для *dead-letter* очереди, который периодически забирает сообщения и выпоняет *reject* либо с `requeue=true`, либо с `requeue=false`. При передаче `requeue=true` сообщение останется в *dead-letter* очереди до следующего получения его подписчиком *dead-letter* очереди. Если же передать `requeue=false`, сообщение уйдет в *WorkExchange*, откуда снова попадет в *WorkQueue* для следующей попытки. Ниже представлена схема реализации.

![Схема с подписчиком dead-letter очереди](/images/re-execution-of-tasks-with-different-repetition-waiting-times-in-rabbitmq/dlq-consumer.png)

В данном случае подписчик сам понимает, нужно ли отправлять сообщение на повторное выполнение, например, в зависимости от параметров `count` и `time` соответсвующего подзаголовка `x-death` сообщения. В оличие от предыдущего способа, эта схема не является громоздкой и ее размер не зависит от лимита на количество повторов. Также нет необходимости пересоздавать очереди при переконфигурации времени ожидания. Само время ожидания между повторами может формироваться по определнному закону, например: `2 * count`. Это может быть удобным в некоторых случаях.
