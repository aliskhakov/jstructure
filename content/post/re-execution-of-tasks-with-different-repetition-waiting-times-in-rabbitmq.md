---
title: "Повторная обработка сообщений в RabbitMQ с различным временным интервалом ожидания между повторами"
date: 2017-12-28T09:47:28+03:00
draft: false
tags: ["RabbitMQ", "DLX"]
description: 'На практике бывают случаи, когда при сбоях выполнения задач, между попытками повторного выполнения, необходимо подождать какое-то время. Например, в процессе выполнения задачи внешняя система была недоступна. Так как количество повторов, как правило, лимитировано, то нет смысла тут же пробовать выполнить задачу еще раз. Внешняя система может стать доступной, например, через минуту. Я уже касался возможности установки временного интервала между попытками обработки сообщений в статье &laquo;[Повторное выполнение задач в RabbitMQ](/post/re-execution-of-tasks-in-rabbitmq/)&raquo;. Однако, бывают случаи, когда необходимо после каждой неудачной попытки изменять временной интервал перед следующим повтором. В этой статье усложним функционал повторного выполнения задач, добавив возможность установки различного временного интервала между попытками обработки сообщений.'
---

Попробуем модифицировать [решение 4]({{< relref "post/re-execution-of-tasks-in-rabbitmq.md" >}}), которое обеспечивает следующая схема. На входе имеем точку обмена *WorkExchange*, которая маршрутизирует сообщения в очередь *WorkQueue*. Эту очередь слушает наш воркер. В случае успешной обработки сообщения воркером, оно удаляется из очереди, но если произошел сбой, сообщение публикуется в точку доступа *RetryExchange* ([*DLX*](https://www.rabbitmq.com/dlx.html)). Далее оно перенаправляются в очередь *RetryQueue*, объявленную с параметром `x-message-ttl`. После достижения заданного временного лимита (*TTL*) сообщение, минуя точку обмена *WorkExchange*, опять попадает в очередь *WorkQueue*, откуда его забирает воркер, чтобы попробывать обработать сообщение еще раз. Этот цикл можно повторять до достижения заданного в воркере лимита на количество повторов.

Первым делом в голову приходит мысль добавления нескольких очередей для *RetryExchange* с различными параметрами `x-message-ttl`. Для этого нужно реализовать роутинг в точке обмена *RetryExchange*. Рассмотрим различные типы точек обмена, существующие в RabbitMQ. Так как *routing key* у всех сообщений одинаковый, типы *direct* и *topic* для точки доступа *RetryExchange* не подойдут, несмотря на то, что при возврате сообщения в очередь, можно поменять *routing key*, так как это будет происходить для всех сообщений. Очевидно, что тип *fanout* тоже не подходит, так как разветвление в данном случае не имеет смылса, нам же нужен роутинг. А вот на типе *headers* можно попробовать остановиться. Дело в том, что сообщения, попадающие в точку обмена *DLX*, имеют специальный заголовок `x-death`, содержащий в себе список словарей, которые содерджат информацию о количестве попаданий в различные точки обмена *DLX* при разных условиях. Пример заголовка `x-death` показан ниже.

```
x-death:        count: 4
             exchange: RetryExchange
                queue: RetryQueue
               reason: expired
         routing-keys: WorkQueue
                 time: 1510583141
                 
                count: 3
             exchange: WorkExchange
                queue: WorkQueue
               reason: rejected
         routing-keys: WorkQueue
                 time: 1510583141
```

Видно, что вся информация имеется, но в RabbitMQ отсутствует возможность связывания очереди с точкой обмена по вложенным заголовкам, например, по правилу `x-death[1].count = 3`. Таким образом, вынуждены отказаться от идеи добавления нескольких очередей для *RetryExchange*, потому что в *RabbitMQ* не возможно реализовать соответствующую маршрутизацию сообщений.

Идем дальше. Можно попробовать создать цепочку *dead-letter* очередей с различными параметрами `x-message-ttl`, как показано на схеме ниже. После каждой *dead-letter* очереди, сообщение, минуя соответствующую точку обмена *DLX*, попадает в новую очередь задач. Слушатель подписан на каждую из них.

![Схема с подписчиком dead-letter очереди](/images/re-execution-of-tasks-with-different-repetition-waiting-times-in-rabbitmq/multiple-ttl.png)

Эта схема будет работать, но выглядит довольно громоздкой. Очевидно, что размер схемы зависит от количества попыток. Так, если лимит количества попыток равен 10, нужно созадть 18 точек обмена и 19 очередей, а слушателю нужно быть подписанным на 10 очередей. Также к недостаткам этого решения можно отнести сложность переконфигурировани *TTL* для одной или нескольких очередей. Так как `x-message-ttl` задается при декларировании очереди, необходимо удалить и создать очереди заново. При этом нужно обеспечить сохранность сообщений, находящихся в них в данный момент времени.

Следующая мысль, которая приходит в голову &mdash; создание подписчика для *dead-letter* очереди, который периодически забирает сообщения и выпоняет *reject* либо с `requeue=true`, либо с `requeue=false`. Если передать параметр `requeue=true`, сообщение останется в *dead-letter* очереди до момента, когда подписчик данной очереди не получит его в следующий раз. В случае же, когда передается параметр `requeue=false`, сообщение попадет в точку обмена *WorkExchange*, откуда снова смаршрутизируется в очередь *WorkQueue* для следующей попытки. Ниже представлена схема описанной реализации.

![Схема с подписчиком dead-letter очереди](/images/re-execution-of-tasks-with-different-repetition-waiting-times-in-rabbitmq/dlq-consumer.png)

В данном случае подписчик сам понимает, нужно ли отправлять сообщение на повторное выполнение, например, в зависимости от параметров `count` и `time` соответствующего подзаголовка `x-death` сообщения. В отличие от предыдущего способа, эта схема не является громоздкой и ее размер не зависит от лимита на количество повторов. Также нет необходимости пересоздавать очереди при переконфигурировании времени ожидания. Само время ожидания между повторами может формироваться по определнному закону, например: `2 * count`. Это может быть удобным в некоторых случаях.
