---
title: "Повторная обработка сообщений в RabbitMQ с различным временным интервалом ожидания между повторами"
date: 2017-12-28T09:47:28+03:00
draft: false
tags: ["RabbitMQ", "DLX"]
description: 'Я уже писал про &laquo;[повторное выполнение задач в RabbitMQ](/post/re-execution-of-tasks-in-rabbitmq/)&raquo;. Однако, на практике бывают случаи, когда при сбоях между повторами выполнения задач, необходимо подождать какое-то время. Например, в процессе выполнения задачи внешняя система была не доступна. Так как количество повторов как правило лимитировано, нет смысла тут же пробовать выполнить задачу еще раз. Внешняя система может стать доступной напрмер через минуту. Иногда также необходимо после каждой неудачной попытки увеличивать временной интервал перед следующим повтором. В этой статье усложним функционал повторного выполнения задач, добавив возможность задания различного временного интервала между попытками обработки сообщений.'
---

Попробуем модифицировать [решение 4]({{< relref "post/re-execution-of-tasks-in-rabbitmq.md" >}}), которое устроено следующим образом. На входе имеем точку обмена *WorkExchange*. На нее подписана очередь *WorkQueue*, которая отправляет сбойные сообщения в *RetryExchange* (*DLX*). Оттуда сообщения перенаправляются в очередь *RetryQueue*, объявленную с параметром `x-message-ttl`. При дотижении заданного *TTL* сообщение заново публикуется в *WorkExchange* и опять попадает в очередь *WorkQueue*. Этот цикл можно повторять до достижения заданного в слушателе лимита.

Первым делом в голову приходит мысль добавления нескольких очередей для *RetryExchange*, с различными параметрами `x-message-ttl`. Для этого нужно реализовать роутинг в точке обмена *RetryExchange*. Рассмотрим различные типы точек обмена, существующие в RabbitMQ. Так как *routing key* у всех сообщений одинаковый, типы *direct* и *topic* для точки доступа *RetryExchange* не подойдут, не смотря на то, что при возврате сообщения в очередь, можно поменять *routing key*, так как это будет происходить для всех сообщений. Очевидно, что тип *fanout* тоже не подходит, так как разветвление в данном случае не имеет смылса, нам же нужен роутинг. А вот на типе *headers* можно попробовать остановиться. Дело в том, что сообщения, попадающие в *DLX*, имеют специальный заголовок `x-death`, содержащий в себе список словарей, которые содерджат информацию о количестве попаданий в различные *DLX* при разных условиях. Пример заголовка `x-death` показан ниже.

```
x-death:        count: 4
             exchange: RetryExchange
                queue: RetryQueue
               reason: expired
         routing-keys: WorkQueue
                 time: 1510583141
                 
                count: 3
             exchange: WorkExchange
                queue: WorkQueue
               reason: rejected
         routing-keys: WorkQueue
                 time: 1510583141
```

Видно, вся информация имеетя, но в RabbitMQ отсутствует возможность связывания очереди с точкой обмена по вложенным заголовкам, например, по правилу `x-death[1].count = 3`. Таким образом, вынуждены отказаться от идеи добавления нескольких очередей для *RetryExchange*, потому что в *RabbitMQ* не возможно реализовать соответствующий роутинг.

Идем дальше. Можно попробовать создать цепочку *dead-letter* очередей с различными параметрами `x-message-ttl`, как показано на схеме ниже. После каждой *dead-letter* очереди, сообщение, минуя соответсвующий *DLX* попадает в новую очередь задач. Слушатель подписан на каждую из них.

![Схема с подписчиком dead-letter очереди](/images/re-execution-of-tasks-with-different-repetition-waiting-times-in-rabbitmq/multiple-ttl.png)

Эта схема будет работать, но выглядит довольно громоздкой. Так, если лимит количества попыток равен 10, нужно созадть 18 точек обмена и 19 очередей, а слушателю нужно быть подписанным на 10 очередей. Также к недостаткам этого решения можно отнести сложность переконфигурировани `TTL` для одной или нескольких очередей. Для этого очереди нужно удалить и создать заново, при этом нужно беспокоиться о сохранности сообщений в них.

Следующая мысль, которая приходит в голову &mdash; создание подписчика для *dead-letter* очереди, который периодически забирает сообщения и выпоняет *reject* либо с `requeue=true`, либо с `requeue=false`. При передаче `requeue=true` сообщение останется в *dead-letter* очереди до следующего получения его подписчиком *dead-letter* очереди. Если же передать `requeue=false`, сообщение уйдет в *WorkExchange*, откуда снова попадет в *WorkQueue* для следующей попытки. Ниже представлена схема реализации.

![Схема с подписчиком dead-letter очереди](/images/re-execution-of-tasks-with-different-repetition-waiting-times-in-rabbitmq/dlq-consumer.png)

В данном случае подписчик сам понимает, нужно ли отправлять сообщение на выполнение, например, в зависимости от параметров `count` и `time` соответсвующего подзаголовка `x-death` сообщения. В оличае от предыдущего способа, здесь нет необходимости пересоздавать очереди при переконфигурации времени ожидания. Само время ожидания между повторами может формироваться по определнному закону, например: `2 * count`. Это может быть удобным в некоторых ситуациях.
