---
title: "Повторное выполнение задач с разным временем ожидания повтора в RabbitMQ"
date: 2017-11-14T09:47:28+03:00
draft: true
tags: ["RabbitMQ", "DLX"]
---

Я уже писал про &laquo;[повторное выполнение задач в RabbitMQ]({{< relref "post/re-execution-of-tasks-in-rabbitmq.md" >}})&raquo;. В этой статье усложним требуемый функционал, добавив возможность конфигурирования времени ожидания повтора в зависимости от текущего значния счетчика повторов.

Попробуем модифицировать [решение 4]({{< relref "post/re-execution-of-tasks-in-rabbitmq.md" >}}). Итак, на входе имеем точку обмена *WorkExchange*. На нее подписана очередь *WorkQueue*, отправляющая сбойные сообщения в *RetryExchange* (*DLX*), откуда сообщения перенаправляются в очередь *RetryQueue*, объявленную с параметром `x-message-ttl`. При дотижении ttl сообщение заново публикуется в *WorkExchange* и опять попадает в очередь *WorkQueue*. Этот цикл можно повторять до достижения заданного в слушателе лимита.

Первым делом в голову приходит мысль добавления новых очередей для *RetryExchange*, с различными параметрами `x-message-ttl`. Но для этого нужно решить вопрос с роутингом в *RetryExchange*. Использовать *routing key* не получится, так как он у всех одинаковый, поэтому типы *direct* и *topic* для точки доступа *RetryExchange* не подойдут. Очевидно, что тип *fanout* тоже не подходит, так как разветвление не требуется. А вот на типе *headers* можно попробовать остановиться. Сообщения, попадающие в *DLX*, имеют специальный заголовок `x-death`, содержащий в себе список словарей, которые содерджат информацию о количестве попаданий в различные *DLX* при разных условиях. Пример заголовка `x-death` показан ниже.

```
x-death:        count: 4
             exchange: RetryExchange
                queue: RetryQueue
               reason: expired
         routing-keys: WorkQueue
                 time: 1510583141
                 
                count: 3
             exchange: WorkExchange
                queue: WorkQueue
               reason: rejected
         routing-keys: WorkQueue
                 time: 1510583141
```

Казалось бы, вся информация есть, но **в RabbitMQ нет возможности связать очередь с точкой обмена по правилу `x-death[1].count = 3`**. Таким образом, мы вынуждены отказаться от идеи задания *TTL* для *dead-letter* очереди, потому что в *RabbitMQ* не возможно создавать несколько очередей с разными *TTL* для достижения нашей цели в виду отсутсвия возможности реализации роутинга.

![Схема с подписчиком dead-letter очереди](/images/re-execution-of-tasks-with-different-repetition-waiting-times-in-rabbitmq/multiple-ttl.png)

Следующая мысль, которая приходит в голову &mdash; создание подписчика (*consumer*) для *dead-letter* очереди, который периодически забирает сообщения и, в зависимости от параметров `count` и `time` необходимого словаря заголовка `x-death`, делает *reject* либо с `requeue=true`, либо с `requeue=false`. При `requeue=true` сообщение останется в *dead-letter* очереди до следующего получения его подписчиком. Если же передать `requeue=false`, сообщение уйдет в *WorkExchange*, откуда снова попадет в *WorkQueue* для следующей попытки. Ниже представлена схема реализации.

![Схема с подписчиком dead-letter очереди](/images/re-execution-of-tasks-with-different-repetition-waiting-times-in-rabbitmq/dlq-consumer.png)

